### 도커

쿠버네티스는 컨테이너를 오케스트레이션하고, 오케스트레이션하는 기본 단위가 pod이다.

이 pod은 컨테이너로 이뤄져 있다.

여기서 컨테이너를 만들고 관리하는 도구가 도커다.

워커 노드라는 노드 단위로 pod을 관리하고, 워커 노드와 마스터 노드를 합쳐 쿠버네티스 클러스터라함.

pod은 1개 이상의 컨테이너로 이뤄져 있다. 

pod은 쿠버네티스로부터 IP를 받아 컨테이너가 외부로 통신할 수 있는 경로를 제공하고 컨테이너들이 정상 작동하는지 확인하고 네트워크나 저장공간을 서로 공유한다.

컨테이너 : 한 운영체제 안에서 커널을 공유하며 개별적인 실행 환경을(CPU, 네트워크, 메모리 등 자원을 독자적으로 사용하도록 할당된 환경) 제공하는 격리된 공간

컨테이너 안에서 실행되는 프로세스를 구분하는 ID도 컨테이너 안에 격리돼 관리됨(시스템 자원, Process ID 등은 한 워커 노드의 커널에서 할당함)

리눅스와 유닉스는 호스트 운영체제 안에서 자원을 분리해 할당하고, 실행되는 프로세스를 격리해 관리하는 방법을 제공해옴. 근데 이게 파일 시스템 설정하고, 자원 관리하는게 복잡하기 때문에 이걸 쉽게 만들어주는 도구가 바로 도커다. 

### 도커로 컨테이너 다루기

이미지 찾기 → 실행 → 디렉터리와 연결 → 삭제

컨테이너 이미지는 베이그런트 이미지와 유사한데, 이미지 그대로를 사용하는게 아니라 도커와 같은 CRI로 불러들여야 컨테이너가 실제 작동함. 컨테이너를 삭제할 땐 내려받은 이미지와 이미 실행된 컨테이너 모두를 삭제해야 디스크 용량을 온전히 확보할 수 있음

### 컨테이너 이미지

이미지는 레지스트리라고 하는 저장소에 모임 → 도커 허브가 가장 유명함

쿠버네티스 마스터 노드에 접속해 검색할 수도 있음

```bash
docker search nginx

# search로 찾은 이미지를 내려받을 수 있음
docker pull nginx
```

이미지 내려 받을 때 태그, 레이어, 이미지의 고유 식별 값 등을 볼 수 있다.

- 태그(tag) : 이름이 동일한 이미지에 추가하는 식별자. 아무 조건을 주지 않으면 기본으로 latest 태그가 적용됨
- 레이어(layer) : pull을 수행해 내려받은 레이어. 1개의 이미지는 여러 개의 레이어로 이뤄져 레이어마다 pull complete 메시지가 발생. 이미지는 같은 내용일 경우 여러 이미지에 동일한 레이어를 공유해 전체 용량이 감소. → 다른 태그 다운 받을 때 같은 레이어는 이미 다운로드 완료 상태로 다른 레이어 다운으로 넘어감.
- 다이제스트(digest) : 이미지 고유 식별자. 이미지에 포함된 내용과 생성환경을 식별할 수 있다. 식별자는 해시 함수로 생성되며 이미지가 동일한지 검증하는데 사용함. 이름이나 태그는 이미지를 생성할 때 임의로 지정하므로 이름, 태그가 같다고 같은 이미지라 할 수 없으나 다이제스트가 같으면 같은 이미지임.
- 상태(state) : 이미지를 내려받은 레지스트리, 이미지, 태그 등 상태 정보를 확인할 수 있음. 형식은 ‘레지스트리 이름/이미지 이름:태그’

### 컨테이너 실행하기

```bash
# 내려 받은 이미지 기반으로 새로 컨테이너 실행
docker run -d --restart always nginx
# 결과값으로 16진수 문자열 출력 <- 컨테이너 식별 ID임
# -d(--detach) : 컨테이너를 백그라운드에서 구동, ctrl+c 누르면 애플리케이션, 컨테이너 함께 중단
# --restart alwyas : 컨테이너가 오류 발생해 중지해도 즉시 재시작하거나, 도커 서비스 작동시
# 컨테이너를 자동 시작하도록 설정

# 생성 컨테이너 상태 확인(ps: process status)
docker ps
# CONTAINER ID: 컨테이너 식별 ID
# IMAGE: 컨테이너 생성하는데 사용된 이미지
# COMMAND: 컨테이너 생성 시 내부에서 작동할 프로그램을 실행하는 명령어
# CREATED: 컨테이너 생성 시각
# STATUS: 작동 시작 시각
# PORTS: 컨테이너가 사용하는 포트와 프로토콜
# NAMES: 컨테이너 이름

# 컨테이너 지정 검색(앞에 기록해둔 16진수 ID를 넣어야함)
# -f(filter): kdy=value 형식으로 입력
docker ps -f id=cec73dfak...

# 필터링에 자주 사용되는 키에는 id, name, label, exited, status, ancestor가 있음
```

여기까지 하면 현재 호스트 네트워크와 도커 네트워크 사이 경로 설정이 돼있지 않아 컨테이너의 80번 포트로 접속할 수 없다. 응답을 컨테이너에서 처리하길 원하면 80번트로 들어온 것을 컨테이너에서 받아줄 수 있는 포트로 연결해주는 설정이 필요함.

**추가로 경로를 설정해 정상적으로 컨테이너 실행하기**

```bash
# 새로운 컨테이너 추가, -p(publish) : 외부에서 호스트로 보낸 요청을 컨테이너 내부로 전달
docker run -d -p 8080:80 --name nginx-exposed --restart always nginx
# -p <요청 받을 호스트 포트>:<연결할 컨테이너 포트>

docker ps -f name=nginx-exposed
# PORTS를 확인하면 0.0.0.0:8080->80/tcp로 되어 있음
# 0.0.0.0의 8080 포트로 들어오는 요청을 컨테이너 내부의 80번 포트로 전달하는 의미
# 이제 웹브라우저에서 컨테이너로 접근가능함.
```

### 컨테이너 내부 파일 변경하기

컨테이너 내부에서 컨테이너 외부 파일을 사용하는 방법은 4가지가 있음

- docker cp
    
    docker cp <호스트 경로> <컨테이너 이름>:<컨테이너 내부 경로> 
    
    호스트에 위치한 파일을 구동 중인 컨테이너 내부에 복사
    
    컨테이너에 임시로 필요한 파일이 있을 때 단편적으로 전송할 때나 컨테이너에 저장돼 있는 설정 및 로그를 추출해 확인하는 목적으로 사용
    
- Dockerfile ADD
    
    Dockerfile을 기반으로 이미지 생성, Dockerfile ADD라는 구문으로 컨테이너 내부로 복사할 파일을 지정하면 이미지 빌드 시 지정 파일이 이미지 내부로 복사된다.
    
    해당 이미지 기반으로 구동한 컨테이너는 복사한 파일을 사용할 수 있으나, 사용자가 원하는 파일을 선택해 사용할 수 없다는 단점이 있음
    
- 바인드 마운트
    
    호스트의 파일 시스템과 컨테이너 내부를 연결해 어느 한쪽에서 작업한 내용이 양쪽에 동시에 반영되는 방법
    
    새로운 컨테이너를 구동해도 호스트와 연결한 파일이나 디렉터리의 경로만 지정하면 다른 컨테이너에 있는 파일을 새로 생성한 컨테이너와 연결할 수 있다. 데이터베이스의 데이터 디렉터리나 서버의 첨부 파일 디렉터리처럼 컨테이너가 바뀌어도 없어지면 안되는 자료는 이 방법으로 보존할 수 있음
    
- 볼륨
    
    바인드 마운트와 유사하나, 호스트의 특정 디렉터리가 아닌 도커가 관리하는 볼륨을 컨테이너와 연결한다. 여기서의 볼륨은 쿠버네티스의 볼륨 구조와 유사하다. 도커가 관리하는 볼륨 공간을 NFS 같은 공유 디렉터리에 생성한다면 다른 호스트에서도 도커가 관리하는 볼륨을 함께 사용할 수 있다. 
    

1. 바인드 마운트로 호스트와 컨테이너 연결
    
    ```bash
    # 컨테이너 내부에 연결할 디렉터리를 호스트에 생성
    mkdir -p /root/html
    
    # 컨테이너 구동, 처음 접속할 때 노출되는 페이지의 컨테이너 디렉터리와 호스트의 /root/html 디렉터리 연결
    # -v(-volume) : 호스트 디렉터리와 컨테이너 디렉터리 연결 옵션
    # -v <host dir path>:[container dir path]
    # 바운드 마스트의 특징: 호스트 디렉터리의 내용을 그대로 컨테이너 디렉터리에 덮어씀
    # 즉, 컨테이너 디렉터리에 어떤 내용이 있든 삭제됨을 유의!
    docker run -d -p 8081:80 \
    -v /root/html:/usr/share/nginx/html --restart always --name nginx-bind-mounts nginx
    
    # 컨테이너 조회해 status 정상 확인
    docker ps -f name=nginx-bind-mounts
    
    # 컨테이너 내부와 연결된 /root/html/ 확인(현재는 빈 상태)
    ls /root/html
    
    # index.html을 /root/html/(호스트)에 복사
    # 바인드 마운트로 index.html이 호스트에서 컨테이너로 전달됨
    cp ~/~~~/index-BindMount.html /root/html/index.html
    ls /root/html 
    
    # 컨테이너 내부 확인
    # docker exec <컨테이너 ID | 이름> <명령어>
    docker exec e7ca /usr/share/nginx/html
    ```
    
2. 볼륨으로 호스트와 컨테이너 연결
    
    ```bash
    # 볼륨 생성
    docker volume create nginx-volume
    
    # 볼륨 조회
    docker volume inspect nginx-volume
    
    # 볼륨으로 생성된 디렉터리 확인
    ls /var/lib/docker/volumes/nginx-volume/_data
    
    # 호스트와 컨테이너 디렉터리 연결할 컨테이너 구동
    docker run -d -v nginx-volume:/usr/share/nginx/html \
    -p 8082:80 --restart always --name nginx-volume nginx
    
    # 볼륨 디렉터리 확인 -> 바운드 마운트와 달리 빈 디렉터리를 덮어쓰지 않고 기존 파일을 보존함
    # 양쪽을 서로 동기화하는 구조
    ls /var/lib/docker/volumes/nginx-volume/_data
    
    # 바꿀 파일을 볼륨 디렉터리로 복사해 볼륨에서 변경 내용이 컨테이너 디렉터리에 동기화되는지 확인
    cp ~/~~~/index-Volume.html /var/lib/docker/volumes/nginx-volume/_data/index.html
    ```
    

** 볼륨 경로는 수정이 가능함

### 사용하지 않는 컨테이너 정리하기

1. 컨테이너 정지
    
    ```bash
    # 생성 컨테이너 조회
    # ancestor 키는 컨테이너 생성 시 사용한 이미지를 기준으로 필터링
    docker ps -f ancestor=nginx
    
    # 컨테이너 정지
    # docker stop <container name | ID>
    docker stop tender_snyder
    
    # nginx 이미지를 사용하는 모든 컨테이너 한꺼번에 정지하기
    docker ps -q -f ancestor=nginx
    
    # docker stop 인자로 사용도 가능
    docker stop $(docker ps -q -f ancestor=nginx)
    
    # 정지된 거지 삭제된 것은 아님. 
    # 정지된 컨테이너까지 모두 조회하려면 -a 옵션으로 검색
    docker ps -a -f ancestor=nginx
    ```
    
2. 컨테이너와 이미지 삭제하기
    
    ```bash
    # 한꺼번에 정지된 모든 컨테이너 삭제
    docker rm $(docker ps -aq -f ancestor=nginx)
    
    # 확인
    docker ps -a -f ancestor=nginx
    
    # 내려받은 이미지가 용량을 차지하지 이것도 삭제
    # rmi(remove image) - 컨테이너 삭제 상태에만 삭제할 수 있음(이미지 삭제 전엔 컨테이너 삭제가 우선!)
    docker rmi $(docker images -q nginx)
    ```