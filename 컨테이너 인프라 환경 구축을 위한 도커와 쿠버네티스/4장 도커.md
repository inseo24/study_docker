### 도커

쿠버네티스는 컨테이너를 오케스트레이션하고, 오케스트레이션하는 기본 단위가 pod이다.

이 pod은 컨테이너로 이뤄져 있다.

여기서 컨테이너를 만들고 관리하는 도구가 도커다.

워커 노드라는 노드 단위로 pod을 관리하고, 워커 노드와 마스터 노드를 합쳐 쿠버네티스 클러스터라함.

pod은 1개 이상의 컨테이너로 이뤄져 있다. 

pod은 쿠버네티스로부터 IP를 받아 컨테이너가 외부로 통신할 수 있는 경로를 제공하고 컨테이너들이 정상 작동하는지 확인하고 네트워크나 저장공간을 서로 공유한다.

컨테이너 : 한 운영체제 안에서 커널을 공유하며 개별적인 실행 환경을(CPU, 네트워크, 메모리 등 자원을 독자적으로 사용하도록 할당된 환경) 제공하는 격리된 공간

컨테이너 안에서 실행되는 프로세스를 구분하는 ID도 컨테이너 안에 격리돼 관리됨(시스템 자원, Process ID 등은 한 워커 노드의 커널에서 할당함)

리눅스와 유닉스는 호스트 운영체제 안에서 자원을 분리해 할당하고, 실행되는 프로세스를 격리해 관리하는 방법을 제공해옴. 근데 이게 파일 시스템 설정하고, 자원 관리하는게 복잡하기 때문에 이걸 쉽게 만들어주는 도구가 바로 도커다. 

### 도커로 컨테이너 다루기

이미지 찾기 → 실행 → 디렉터리와 연결 → 삭제

컨테이너 이미지는 베이그런트 이미지와 유사한데, 이미지 그대로를 사용하는게 아니라 도커와 같은 CRI로 불러들여야 컨테이너가 실제 작동함. 컨테이너를 삭제할 땐 내려받은 이미지와 이미 실행된 컨테이너 모두를 삭제해야 디스크 용량을 온전히 확보할 수 있음

### 컨테이너 이미지

이미지는 레지스트리라고 하는 저장소에 모임 → 도커 허브가 가장 유명함

쿠버네티스 마스터 노드에 접속해 검색할 수도 있음

```bash
docker search nginx

# search로 찾은 이미지를 내려받을 수 있음
docker pull nginx
```

이미지 내려 받을 때 태그, 레이어, 이미지의 고유 식별 값 등을 볼 수 있다.

- 태그(tag) : 이름이 동일한 이미지에 추가하는 식별자. 아무 조건을 주지 않으면 기본으로 latest 태그가 적용됨
- 레이어(layer) : pull을 수행해 내려받은 레이어. 1개의 이미지는 여러 개의 레이어로 이뤄져 레이어마다 pull complete 메시지가 발생. 이미지는 같은 내용일 경우 여러 이미지에 동일한 레이어를 공유해 전체 용량이 감소. → 다른 태그 다운 받을 때 같은 레이어는 이미 다운로드 완료 상태로 다른 레이어 다운으로 넘어감.
- 다이제스트(digest) : 이미지 고유 식별자. 이미지에 포함된 내용과 생성환경을 식별할 수 있다. 식별자는 해시 함수로 생성되며 이미지가 동일한지 검증하는데 사용함. 이름이나 태그는 이미지를 생성할 때 임의로 지정하므로 이름, 태그가 같다고 같은 이미지라 할 수 없으나 다이제스트가 같으면 같은 이미지임.
- 상태(state) : 이미지를 내려받은 레지스트리, 이미지, 태그 등 상태 정보를 확인할 수 있음. 형식은 ‘레지스트리 이름/이미지 이름:태그’

### 컨테이너 실행하기

```bash
# 내려 받은 이미지 기반으로 새로 컨테이너 실행
docker run -d --restart always nginx
# 결과값으로 16진수 문자열 출력 <- 컨테이너 식별 ID임
# -d(--detach) : 컨테이너를 백그라운드에서 구동, ctrl+c 누르면 애플리케이션, 컨테이너 함께 중단
# --restart alwyas : 컨테이너가 오류 발생해 중지해도 즉시 재시작하거나, 도커 서비스 작동시
# 컨테이너를 자동 시작하도록 설정

# 생성 컨테이너 상태 확인(ps: process status)
docker ps
# CONTAINER ID: 컨테이너 식별 ID
# IMAGE: 컨테이너 생성하는데 사용된 이미지
# COMMAND: 컨테이너 생성 시 내부에서 작동할 프로그램을 실행하는 명령어
# CREATED: 컨테이너 생성 시각
# STATUS: 작동 시작 시각
# PORTS: 컨테이너가 사용하는 포트와 프로토콜
# NAMES: 컨테이너 이름

# 컨테이너 지정 검색(앞에 기록해둔 16진수 ID를 넣어야함)
# -f(filter): kdy=value 형식으로 입력
docker ps -f id=cec73dfak...

# 필터링에 자주 사용되는 키에는 id, name, label, exited, status, ancestor가 있음
```

여기까지 하면 현재 호스트 네트워크와 도커 네트워크 사이 경로 설정이 돼있지 않아 컨테이너의 80번 포트로 접속할 수 없다. 응답을 컨테이너에서 처리하길 원하면 80번트로 들어온 것을 컨테이너에서 받아줄 수 있는 포트로 연결해주는 설정이 필요함.

**추가로 경로를 설정해 정상적으로 컨테이너 실행하기**

```bash
# 새로운 컨테이너 추가, -p(publish) : 외부에서 호스트로 보낸 요청을 컨테이너 내부로 전달
docker run -d -p 8080:80 --name nginx-exposed --restart always nginx
# -p <요청 받을 호스트 포트>:<연결할 컨테이너 포트>

docker ps -f name=nginx-exposed
# PORTS를 확인하면 0.0.0.0:8080->80/tcp로 되어 있음
# 0.0.0.0의 8080 포트로 들어오는 요청을 컨테이너 내부의 80번 포트로 전달하는 의미
# 이제 웹브라우저에서 컨테이너로 접근가능함.
```