### 4장까지 진행 과정 정리

1. 깃헙 등 저장소에 올린 어플리케이션 소스 코드를 내려받아 도커 컨테이너 이미지로 빌드(docker build)
2. 빌드한 컨테이너 이미지를 쿠버네티스에서 사용할 수 있도록 레지스트리에 등록(docker push)
3. 레지스트리에 등록된 이미지를 기반으로 쿠버네티스 오브젝트를 생성(kubectl create)
4. 생성한 오브젝트(pod/deployement)를 외부에서 접속할 수 있도록 서비스 형태로 노출(kubectl expose)

이런 과정을 파이프 라인이라고 한다.

이를 도구를 통해 자동화할 수 있다.

자동화는 크게 지속적 통합(CI, Continuous Integration), 지속적 배포(CD, Continuous Deployment) 두 가지로 정의되고, 일반적으로 둘을 합쳐 CI/CD라고 한다.

### 컨테이너 인프라 환경에서 CI/CD

CI은 일반적으로 코드를 커밋하고 빌드했을 때 정상적으로 작동하는지 반복적으로 컴증해 애플리케이션의 신뢰성을 높이는 작업이다. CI 과정을 마친 애플리케이션은 신뢰할 수 있는 상태가 된다. 

CD는 CI 과정에서 생성된 신뢰성 있는 애플리케이션을 실제 사용 환경에 자동으로 배포하는 것을 의미한다. 배포할 때 고려할 사항이 여러 가지 있는데, 이를 CD에 미리 정의하면 실수를 줄이고, 실제 적용 시간도 최소화할 수 있다.

개발자가 소스를 커밋하고 푸시하면 CI 단계로 들어간다. CI 단계에서는 애플리케이션이 자동 빌드되고 테스트를 거쳐 배포할 수 있는 애플리케이션인지 확인한다. 테스트를 통과하면 신뢰할 수 있는 애플리케이션으로 간주하고 CD 단계로 넘어간다. CD 단계에서는 애플리케이션을 컨테이너 이미지로 만들어서 파드, 디플로이먼트, 스테이트풀셋 등 다양한 오브젝트 조건에 맞춰 미리 설정한 파일을 통해 배포한다.

**CI/CD 도구**

| 구분 | 팀시티 | 깃허브 액션 | 뱀부 | 젠킨스 |
| --- | --- | --- | --- | --- |
| 설치 방식 | 직접 설치 | 깃허브 연동 | 직접 설치 | 직접 설치 |
| 연계 기능 | 보통 | 보통 | 부족 | 매우 많음 |
| 가격 | 무료/유료 | 무료/유료 | 유료 | 무료 |
| 기능 추가 | 보통 | 매우 다양 | 보통 | 매우 다양 |
| 범용성 | 보통 | 매우 큼 | 보통 | 매우 큼 |
| 정보량 | 부족 | 많음 | 많음 | 매우 많음 |

이외에 클라우드 서비스에서 제공하는 AWS CodeBuilde, CodePipeline, CodeDeploy, GCP CloudBuild, Azure Pipeline 등이 있다. 배포가 중요한 환경이라면 CD 기능이 중점인 Spinnaker나 아르고 CD(Argo CD)를 선택적으로 도입할 수도 있다.

개발자가 작성한 애플리케이션 코드를 소스 코드 저장소에 푸시하면 쿠버네티스 내부에 설치된 젠킨스는 앱 코드를 빌드하고 레지스트리에 푸시한 후 쿠버네티스에서 사용 가능한 형태로 배포한다. 젠킨스는 작업 내용을 아이템 단위로 정의하고 조건에 따라 자동으로 작업을 수행해 효율을 높이고 실수를 줄인다.

컨테이너 인프라 환경에서 젠킨스를 사용하는 주된 이유는 애플리케이션을 컨테이너로 만들고 배포하는 과정을 자동화하기 위함이다. 젠킨스는 컨트롤러와 에이전트 형태를 구성한 다음 배포해야 하며 여기에 필요한 설정을 모두 넣어야 한다. 동적인 변경 사항을 간편하고 빠르게 적용할 수 있도록 도와주는 도구가 2가지가 있다. 하나는 커스터마이즈고 다른 하나는 헬름이다. 

### 배포 간편화 도구 비교하기

| 구분 | kubectl | kustomize | Helm |
| --- | --- | --- | --- |
| 설치 방법 | 쿠버네티스 기본 포함 | 별도 실행 파일 또는 쿠버네티스에 통합 | 별도 설치 |
| 배포 대상 | 정적 yaml 파일 | 커스터마이즈 파일 | 패키지(차트) |
| 주 용도 | 오브젝트 관리 및 배포 | 오브젝트의 가변적 배포 | 패키지 단위 오브젝트 배포 및 관리 |
| 가변적 환경 | 대응 힘듦(yaml 수정 필요) | 간단한 대응 가능 | 복잡한 대응 가능 |
| 기능 복잡도 | 단순 | 보통 | 복잡함 |

### 커스터마이즈의 작동 원리

커스터마이즈는 yaml 파일에 값을 정의해서 사용자가 원하는대로 커스터마이징할 수 있다. kustomize 명령과 create 옵션으로 kustomization.yaml이란 기본 매니페스트를 만들고, 이 파일에 변경해야 하는 값들을 적용한다. 그리고 build 옵션으로 변경할 내용이 적용된 최종 yaml 파일을 저장하거나 변경된 내용이 바로 실행되도록 지정한다.

커스터마이즈로 MetalLB를 구성해보자.

- kustomization.yaml 파일에 원하는 내용을 담고
- 그걸 반영한 MetalLB 매니페스트를 생성하고
- 이 매니페스트를 통해 배포

```bash
# 커스터마이즈 압축 파일을 내려 받은 후 이를 해제하고 /usr/local/bin으로 이동
~/~~~/kustomize-install.sh

# 커스터마이즈에서 리소스 및 주소 할당 영역(pool)을 구성할 때 사용하는 파일 확인을 위해
# 디렉터리를 이동하고 metallb-l2config.yaml, metallb.yaml, namespace.yaml 파일 확인
cd ~/~~/5.2.2
ls

# kustomization.yaml 생성
# --namespace : 작업의 네임스페이스 설정
# --resource : 커스터마이즈 명령을 이용해 kustomization.yaml를 만들기 위한 소스 파일 정의
kustomize create --namespace=metallb-system --resources namespace.yaml, metallb.yaml, metallb-l2config.yaml

# 생성된 yaml 파일 확인
cat kustomization.yaml

# 설치된 이미지를 안정적인 버전으로 유지하기 위해 이미지 태그를 v0.8.2로 지정
kustomize edit set image metallb/controller:v0.8.2
kustomize edit set image metallb/speaker:v0.8.2

# tag 설정 확인
cat kustomization.yaml

# Metallb 설치를 위한 매니페스트 생성
kustomize build

# 배포
kustomize build | kubectl apply -f -

# 정상 배포됐는지 확인
kubectl get pods -n metallb-system

# tag 확인
kubectl describe pods -n metallb-system | grep Image:

# 커스터마이즈로 metallb가 생성됐으니 디플로이먼트 1개 배포 후 load balancer 타입으로 노출하고
# ip 정상 할당되는지 확인
kubectl create deployment echo-ip --image=sysnet4admin/echo-ip
kubectl expose deployment echo-ip --type=LoadBalancer --port=80
kubectl get service echo-ip

# 호스트 노트북에서 192.168.1.11로 접속해 정상 응답 확인
```

### 헬름의 작동 원리

헬름:  쿠버네티스에서 패키지를 쉽게 배포할 수 있도록 패키지를 관리하는 쿠버네티스 전용 패키지 매니저

- 일반적으로 패키지는 실행 파일 + 실행 환경에 필요한 의존성 파일 + 환경 정보 묶음
- 외부 저장소에서 패키지 정보를 받아와 패키지를 안정적으로 관리하는 도구
- 자바의 maven, 리눅스의 yum, apt, 파이썬의 pip라고 생각하면 됨!

패키지 매니저의 역할은 기본적으로 쉬운 설치와 관리다. 그 외에는..

- 패키지 검색
- 패키지 관리: 저장소에서 패키지 정보 확인, 패키지 설치, 삭제, 업그레이드, 되돌리기 등
- 패키지 의존성 관리: 설치할 때 의존하는 소프트웨어 같이 설치, 같이 삭제
- 패키지 보안 관리: 체크섬이라는 값으로 해당 패키지의 소트프웨어나 의존성이 변조됐는지 검사 가능

추가로 헬름을 사용하면 주소 할당 영역도 변경이 가능하다.

헬름 기본 저장소는 아티팩트허브(artifacthub.io)로, 다른 패키지 매니저처럼 외부에 있다. 다른 저장소와 달리 패키지에 대한 경로만 제공한다. 

아티팩트허브 검색을 통해 사용자가 찾고자 하는 애플리케이션 패키지를 검색해 저장된 주소를 확인한다. 이 주소는 각 애플리케이션을 개발하는 주체가 관리한다. 사용자는 설치하려는 애플리케이션의 차트 저장소 주소를 아티팩트허브에서 얻으면 헬름을 통해 주소를 등록한다. 그리고 이를 최신으로 업데이트한 후 차트를 내려받고 설치한다. 이렇게 헬름을 통해 쿠버네티스에 설치된 애플리케이션 패키지를 릴리스라고 한다.

헬름을 통해 배포된 릴리스를 다시 차트를 사용해 업그레이드 할 수 있고 원래대로 되돌릴 수 있다. 또한, 사용하지 않는 헬름 릴리스를 제거할 수도 있다. 

### 헬름으로 MetalLB 한 번에 만들기

```bash
# 헬름 설치, 호환성 이슈로 버전을 고정하고 다운함
export DESIRED_VERSION=v3.2.1; ~/~~~/helm-install.sh

# 아티팩트허브에서 metallb를 검색해 주소를 확인

# 실제 저장소를 등록해 metallb 설치 준비
helm repo add edu https://iac-source.github.io/helm-charts

# 정상 등록되었는지 확인
helm repo list

# 헬름으로 차트 저장소를 추가한 시점의 차트를 로컬 캐시를 저장해 install과 같은 작업 수행시 먼저 
# 로컬에 있는 캐시 정보 참조

# 저장소 추가 이후 변경된 차트가 있으면 변경된 정보를 캐시에 업데이트 할 수 있게 최신 차트 정보 업데이트
helm repo update

# 등록, 업데이트한 저장소로부터 metallb 설치
helm install metallb edu/metallb \
--namespace=metallb-system \
--create-namespace \
--set controller.tag=v0.8.3 \
--set speaker.tag=v0.8.3 \
--set configmap.ipRange=192.168.1.11-192.168.1.29

# 설치된 metallb가 정상 상태인지 확인
kubectl get pods -n metallb-system
kubectl get configmap -n metallb-system

# helm set 옵션 잘 적용되었는지 확인
kubectl describe pods -n metallb-system | grep Image:

# 헬름으로 metallb가 생성됐으니 디플로이먼트 1개 배포 후 load balancer 타입으로 노출하고
# ip 정상 할당되는지 확인
kubectl create deployment echo-ip --image=sysnet4admin/echo-ip
kubectl expose deployment echo-ip --type=LoadBalancer --port=80
kubectl get service echo-ip

# 호스트 노트북에서 192.168.1.11로 접속해 정상 응답 확인
```