### 4장까지 진행 과정 정리

1. 깃헙 등 저장소에 올린 어플리케이션 소스 코드를 내려받아 도커 컨테이너 이미지로 빌드(docker build)
2. 빌드한 컨테이너 이미지를 쿠버네티스에서 사용할 수 있도록 레지스트리에 등록(docker push)
3. 레지스트리에 등록된 이미지를 기반으로 쿠버네티스 오브젝트를 생성(kubectl create)
4. 생성한 오브젝트(pod/deployement)를 외부에서 접속할 수 있도록 서비스 형태로 노출(kubectl expose)

이런 과정을 파이프 라인이라고 한다.

이를 도구를 통해 자동화할 수 있다.

자동화는 크게 지속적 통합(CI, Continuous Integration), 지속적 배포(CD, Continuous Deployment) 두 가지로 정의되고, 일반적으로 둘을 합쳐 CI/CD라고 한다.

### 컨테이너 인프라 환경에서 CI/CD

CI은 일반적으로 코드를 커밋하고 빌드했을 때 정상적으로 작동하는지 반복적으로 컴증해 애플리케이션의 신뢰성을 높이는 작업이다. CI 과정을 마친 애플리케이션은 신뢰할 수 있는 상태가 된다. 

CD는 CI 과정에서 생성된 신뢰성 있는 애플리케이션을 실제 사용 환경에 자동으로 배포하는 것을 의미한다. 배포할 때 고려할 사항이 여러 가지 있는데, 이를 CD에 미리 정의하면 실수를 줄이고, 실제 적용 시간도 최소화할 수 있다.

개발자가 소스를 커밋하고 푸시하면 CI 단계로 들어간다. CI 단계에서는 애플리케이션이 자동 빌드되고 테스트를 거쳐 배포할 수 있는 애플리케이션인지 확인한다. 테스트를 통과하면 신뢰할 수 있는 애플리케이션으로 간주하고 CD 단계로 넘어간다. CD 단계에서는 애플리케이션을 컨테이너 이미지로 만들어서 파드, 디플로이먼트, 스테이트풀셋 등 다양한 오브젝트 조건에 맞춰 미리 설정한 파일을 통해 배포한다.

**CI/CD 도구**

| 구분 | 팀시티 | 깃허브 액션 | 뱀부 | 젠킨스 |
| --- | --- | --- | --- | --- |
| 설치 방식 | 직접 설치 | 깃허브 연동 | 직접 설치 | 직접 설치 |
| 연계 기능 | 보통 | 보통 | 부족 | 매우 많음 |
| 가격 | 무료/유료 | 무료/유료 | 유료 | 무료 |
| 기능 추가 | 보통 | 매우 다양 | 보통 | 매우 다양 |
| 범용성 | 보통 | 매우 큼 | 보통 | 매우 큼 |
| 정보량 | 부족 | 많음 | 많음 | 매우 많음 |

이외에 클라우드 서비스에서 제공하는 AWS CodeBuilde, CodePipeline, CodeDeploy, GCP CloudBuild, Azure Pipeline 등이 있다. 배포가 중요한 환경이라면 CD 기능이 중점인 Spinnaker나 아르고 CD(Argo CD)를 선택적으로 도입할 수도 있다.

개발자가 작성한 애플리케이션 코드를 소스 코드 저장소에 푸시하면 쿠버네티스 내부에 설치된 젠킨스는 앱 코드를 빌드하고 레지스트리에 푸시한 후 쿠버네티스에서 사용 가능한 형태로 배포한다. 젠킨스는 작업 내용을 아이템 단위로 정의하고 조건에 따라 자동으로 작업을 수행해 효율을 높이고 실수를 줄인다.

컨테이너 인프라 환경에서 젠킨스를 사용하는 주된 이유는 애플리케이션을 컨테이너로 만들고 배포하는 과정을 자동화하기 위함이다. 젠킨스는 컨트롤러와 에이전트 형태를 구성한 다음 배포해야 하며 여기에 필요한 설정을 모두 넣어야 한다. 동적인 변경 사항을 간편하고 빠르게 적용할 수 있도록 도와주는 도구가 2가지가 있다. 하나는 커스터마이즈고 다른 하나는 헬름이다. 

### 배포 간편화 도구 비교하기

| 구분 | kubectl | kustomize | Helm |
| --- | --- | --- | --- |
| 설치 방법 | 쿠버네티스 기본 포함 | 별도 실행 파일 또는 쿠버네티스에 통합 | 별도 설치 |
| 배포 대상 | 정적 yaml 파일 | 커스터마이즈 파일 | 패키지(차트) |
| 주 용도 | 오브젝트 관리 및 배포 | 오브젝트의 가변적 배포 | 패키지 단위 오브젝트 배포 및 관리 |
| 가변적 환경 | 대응 힘듦(yaml 수정 필요) | 간단한 대응 가능 | 복잡한 대응 가능 |
| 기능 복잡도 | 단순 | 보통 | 복잡함 |

### 커스터마이즈의 작동 원리

커스터마이즈는 yaml 파일에 값을 정의해서 사용자가 원하는대로 커스터마이징할 수 있다. kustomize 명령과 create 옵션으로 kustomization.yaml이란 기본 매니페스트를 만들고, 이 파일에 변경해야 하는 값들을 적용한다. 그리고 build 옵션으로 변경할 내용이 적용된 최종 yaml 파일을 저장하거나 변경된 내용이 바로 실행되도록 지정한다.

커스터마이즈로 MetalLB를 구성해보자.

- kustomization.yaml 파일에 원하는 내용을 담고
- 그걸 반영한 MetalLB 매니페스트를 생성하고
- 이 매니페스트를 통해 배포

```bash
# 커스터마이즈 압축 파일을 내려 받은 후 이를 해제하고 /usr/local/bin으로 이동
~/~~~/kustomize-install.sh

# 커스터마이즈에서 리소스 및 주소 할당 영역(pool)을 구성할 때 사용하는 파일 확인을 위해
# 디렉터리를 이동하고 metallb-l2config.yaml, metallb.yaml, namespace.yaml 파일 확인
cd ~/~~/5.2.2
ls

# kustomization.yaml 생성
# --namespace : 작업의 네임스페이스 설정
# --resource : 커스터마이즈 명령을 이용해 kustomization.yaml를 만들기 위한 소스 파일 정의
kustomize create --namespace=metallb-system --resources namespace.yaml, metallb.yaml, metallb-l2config.yaml

# 생성된 yaml 파일 확인
cat kustomization.yaml

# 설치된 이미지를 안정적인 버전으로 유지하기 위해 이미지 태그를 v0.8.2로 지정
kustomize edit set image metallb/controller:v0.8.2
kustomize edit set image metallb/speaker:v0.8.2

# tag 설정 확인
cat kustomization.yaml

# Metallb 설치를 위한 매니페스트 생성
kustomize build

# 배포
kustomize build | kubectl apply -f -

# 정상 배포됐는지 확인
kubectl get pods -n metallb-system

# tag 확인
kubectl describe pods -n metallb-system | grep Image:

# 커스터마이즈로 metallb가 생성됐으니 디플로이먼트 1개 배포 후 load balancer 타입으로 노출하고
# ip 정상 할당되는지 확인
kubectl create deployment echo-ip --image=sysnet4admin/echo-ip
kubectl expose deployment echo-ip --type=LoadBalancer --port=80
kubectl get service echo-ip

# 호스트 노트북에서 192.168.1.11로 접속해 정상 응답 확인
```

### 헬름의 작동 원리

헬름:  쿠버네티스에서 패키지를 쉽게 배포할 수 있도록 패키지를 관리하는 쿠버네티스 전용 패키지 매니저

- 일반적으로 패키지는 실행 파일 + 실행 환경에 필요한 의존성 파일 + 환경 정보 묶음
- 외부 저장소에서 패키지 정보를 받아와 패키지를 안정적으로 관리하는 도구
- 자바의 maven, 리눅스의 yum, apt, 파이썬의 pip라고 생각하면 됨!

패키지 매니저의 역할은 기본적으로 쉬운 설치와 관리다. 그 외에는..

- 패키지 검색
- 패키지 관리: 저장소에서 패키지 정보 확인, 패키지 설치, 삭제, 업그레이드, 되돌리기 등
- 패키지 의존성 관리: 설치할 때 의존하는 소프트웨어 같이 설치, 같이 삭제
- 패키지 보안 관리: 체크섬이라는 값으로 해당 패키지의 소트프웨어나 의존성이 변조됐는지 검사 가능

추가로 헬름을 사용하면 주소 할당 영역도 변경이 가능하다.

헬름 기본 저장소는 아티팩트허브(artifacthub.io)로, 다른 패키지 매니저처럼 외부에 있다. 다른 저장소와 달리 패키지에 대한 경로만 제공한다. 

아티팩트허브 검색을 통해 사용자가 찾고자 하는 애플리케이션 패키지를 검색해 저장된 주소를 확인한다. 이 주소는 각 애플리케이션을 개발하는 주체가 관리한다. 사용자는 설치하려는 애플리케이션의 차트 저장소 주소를 아티팩트허브에서 얻으면 헬름을 통해 주소를 등록한다. 그리고 이를 최신으로 업데이트한 후 차트를 내려받고 설치한다. 이렇게 헬름을 통해 쿠버네티스에 설치된 애플리케이션 패키지를 릴리스라고 한다.

헬름을 통해 배포된 릴리스를 다시 차트를 사용해 업그레이드 할 수 있고 원래대로 되돌릴 수 있다. 또한, 사용하지 않는 헬름 릴리스를 제거할 수도 있다. 

### 헬름으로 MetalLB 한 번에 만들기

```bash
# 헬름 설치, 호환성 이슈로 버전을 고정하고 다운함
export DESIRED_VERSION=v3.2.1; ~/~~~/helm-install.sh

# 아티팩트허브에서 metallb를 검색해 주소를 확인

# 실제 저장소를 등록해 metallb 설치 준비
helm repo add edu https://iac-source.github.io/helm-charts

# 정상 등록되었는지 확인
helm repo list

# 헬름으로 차트 저장소를 추가한 시점의 차트를 로컬 캐시를 저장해 install과 같은 작업 수행시 먼저 
# 로컬에 있는 캐시 정보 참조

# 저장소 추가 이후 변경된 차트가 있으면 변경된 정보를 캐시에 업데이트 할 수 있게 최신 차트 정보 업데이트
helm repo update

# 등록, 업데이트한 저장소로부터 metallb 설치
helm install metallb edu/metallb \
--namespace=metallb-system \
--create-namespace \
--set controller.tag=v0.8.3 \
--set speaker.tag=v0.8.3 \
--set configmap.ipRange=192.168.1.11-192.168.1.29

# 설치된 metallb가 정상 상태인지 확인
kubectl get pods -n metallb-system
kubectl get configmap -n metallb-system

# helm set 옵션 잘 적용되었는지 확인
kubectl describe pods -n metallb-system | grep Image:

# 헬름으로 metallb가 생성됐으니 디플로이먼트 1개 배포 후 load balancer 타입으로 노출하고
# ip 정상 할당되는지 확인
kubectl create deployment echo-ip --image=sysnet4admin/echo-ip
kubectl expose deployment echo-ip --type=LoadBalancer --port=80
kubectl get service echo-ip

# 호스트 노트북에서 192.168.1.11로 접속해 정상 응답 확인
```


### 헬름으로 젠킨스 설치하기

```bash
# 젠킨스로 지속적 통합을 하는 과정에 컨테이너 이미지를 레지스트리에 푸시하는 단계가 있음
# 실습을 위해 레지스트리를 우선 구성
docker ps -f name=registry

# 헬름으로 설치되는 젠킨스는 pod에서 동작하는 애플리케이션이므로 PV를 마운트하지 않으면
# pod이 재시작할 때 내부 볼륨에 저장하는 모든 데이터가 삭제됨
# 이를 방지하기 위해 NFS 디렉터리를 만들고 미리 정의된 nfs-exporte.sh jenkins를 실행
# 해당 스크립트에는 NFS용 디렉터리를 만들고 이를 NFS 서비스로 생성하는 과정이 담김
~/~~/nfs-exporter.sh jenkins

# 만들어진 디렉터리에 부여된 사용자 id, 그룹 id 확인
ls -n /nfs-shared

#젠킨스를 헬름 차트로 설치해 앱을 사용하면 젠킨스의 여러 설정 파일과 구성 파일들이 PVC를 통해 PV에 파일로 저장됨
# 이 때 PV에 적절한 접근 ID를 부여하지 않으면 PVC를 사용해 파일을 읽고 쓰는 기능에 문제가 생길 수 있음
# 문제 방지를 위해 젠킨스 PV가 사용할 NFS 디렉터리에 대한 접근 ID를 1000번으로 설정
chown 1000:1000 /nfs_shared/jenkins/
ls -n /nfs_shared

# 사전 구성된 jenkins-volume.yaml 파일을 이용해 PV, PVC 구성하고 확인
kubectl apply -f ~/~~/jenkins-volume.yaml
kubectl get pv jenkins
kubectl get pvc jenkins

# 젠킨스 설치를 위해 필요한 인자를 포함해 사전 구성된 jenkins-install.sh를 실행해 설치
~/~~/jenkins-install.sh

# 젠킨스 디플로이먼트 정보를 비교해서 보기 위해 디플로이먼트 배포 확인
# 젠킨스가 마스터 노드에 있는 걸 확인
kubectl get deployment
kubectl get service jenkins
kubectl get pod -o wide

# 마스터에도 pod이 배포 될 수 있을까?
# 상태 비교 (nl : number lines of files, 줄 번호 추가)
kubectl get node m-k8s -o yaml | nl
...
taints:
	- effect: NoSchedule
	  key: node-role.kubernetes.io/master

...
tolerations:
- effect: NoSchedule
	key: node-role.kubernetes.io/master

# 출력되는 사항 중 taints, tolerations이 이런 결과를 만듦
```

일반적으로 테인트와 톨러레이션은 혼합해서 사용함

테인트: 손에 잡기 싫은 것, 가지지 말았으면 하는 것

톨러레이션: 테인트를 피하기 위해 참아내야 하는 것

사전적인 의미로는 이 정도로 이해하면 된다.

쿠버네티스에선 사전적인 의미와는 반대다. 매우 특별하게 취급해야 하는 것을 테인트로 설정하고, 쉽게 접근하지 못하게 만든다. 그리고 톨러레이션이란 특별한 키를 가져야만 여기에 출입할 수 있게 한다.

즉, 현재 상태에서 마스터 노드에 테인트가 설정돼 있어 특별한 목적으로 사용되는 노드라고 명시해 두었다. 일반적으로 마스터 노드 이외에도 GPU 노드, DB 전용 노드 등의 특별한 목적으로 사용될 때 주로 사용한다.

현재 이 예시에선 관리 편의를 위해 젠킨스 컨트롤러가 여러 곳에 스케줄되지 않고 마스터 노드에서만 스케줄될 수 있게 구성했다. 

테인트와 톨러레이션의 관계를 정의하는 것으로 배포를 유연하게 만들 수 있다.

테인트는 key, value, 그리고 key의 값에 따른 효과의 조합을 통해 테인트를 설정한 노드의 pod 배치 기준을 제시한다. 톨러레이션은 key, value, 효과(effect), 연산자(operator)를 갖고 있다.

테인트의 키와 값의 조합은 테인트를 설정한 노드가 어떤 노드인지 구분하기 위해 사용한다. 키는 필수로 설정해야 하지만 값은 생략할 수 있다. 위에 나온 key: [node-role.kubernetes.io/master](http://node-role.kubernetes.io/master) 는 이 노드가 마스터의 역할을 함을 나타내기 위함이다.

효과(effect)는 테인트와 톨러레이션의 요소인 키 또는 값이 일치하지 않는 pod가 노드에 스케줄되려고 하는 경우 어떤 동작을 할 것인지 나타낸다. 효과는 NoSchedule, PreferNoSchedule, NoExecute을 값으로 가질 수 있는데 효과에 따라 테인트를 설정한 노드는 pod을 새로 배치하는 경우와 pod가 이미 배치된 노드에 대한 동작이 다르다. 

| 효과 | 테인트가 설정된 노드에 대한 신규 배치 | pod이 배치된 노드에 테인트 설정 |
| --- | --- | --- |
| NoSchedule | 노드에 pod 배치 거부 | 노드에 존재하는 pod 유지 |
| PreferNoSchedule | 다른 노드에 pod 배치가 불가능할 때는 노드에 pod 배치 | 노드에 존재하는 pod 유지 |
| NoExecute | 노드에 pod 배치를 거부 | pod을 노드에서 제거 |

톨러레이션에서 키와 효과는 반드시 일치해야 한다. 연산자는 기본적으로 Equal로 동작해 테인트와 톨러레이션을 비교하는 역할을 한다. Exist 연산자는 비교할 키와 값이 존재한다는 가정으로 테인트에 진입할 수 있는 만능 키로 바꿔주는 역할을 한다.

헬름을 통해 젠킨스를 설치했던 스크립트인 [jenkins-install.sh](http://jenkins-install.sh) 내용을 살펴보자.

```bash
#!/usr/bin/env bash

# 기본 설정으로 30분 넘게 사용하지 않으면 세션이 종료되므로 실습에 방해되니
# 세션 유효시간을 1440분(하루)로 변경, 세션 정리 시간 또한 86400초(하루)로 설정
jkopt1="--sessionTimeout=1440"
jkopt2="--sessionEviction=86400"

# 기본 설정으론 시간대가 맞지 않으니 따로 설정
jvopt1="-Duser.timezone=Asia/Seoul"

# 쿠버네티스를 위한 젠킨스 에이전트 노드 설정은 Pod Template을 통해 설정값이 입력됨
# 문제는 가상 머신인 마스터 노드가 재시작하게 되면 이 설정이 초기화되니 
# 설정값을 미리 입력해둔 yaml을 깃헙 저장소에서 가져오게 설정 
jvopt2="-Dcasc.jenkins.config=https://raw.githubusercontent.com/sysnet4admin/_Book_k8sInfra/main/ch5/5.3.1/jenkins-config.yaml"

# edu 차트 저장소의 jenkins 차트를 이용해 jenkins 릴리스를 설치
helm install jenkins edu/jenkins \

# PVC 동적 프로비저닝을 사용할 수 없는 가상 머신 환경이므로 이미 만들어둔 jenkins라는 이름의
# PVC 사용을 설정
--set persistence.existingClaim=jenkins \

# 젠킨스 접속 시 사용할 관리자 비밀번호를 admin으로 설정
# 이 값을 설정하지 않을 경우엔 설치 과정에서 젠킨스가 임의로 생성한 비밀번호를 사용
--set master.adminPassword=admin \

# 젠킨스의 컨트롤러 pod를 쿠버네티스 마스터 노드 m-k8s에 배치하도록 선택
# nodeSelector: 그 뒤에 따라오는 문자열과 일치하는 레이블을 가진 노드에 pod을 스케줄링
--set master.nodeSelector."kubernetes\.io/hostname"=m-k8s \

# 마스터 노드로 pod 배치를 위한 추가 옵션(이 옵션이 없으면 배치가 안됨)
# 테인트가 설정된 상태이기 때문에 톨러레이션 옵션을 설정(톨러레이션 -> 테인트에 대한 예외)
# 톨러레이션에 관해 key, effect, operataor를 설정
--set master.tolerations[0].key=node-role.kubernetes.io/master \
--set master.tolerations[0].effect=NoSchedule \
--set master.tolerations[0].operator=Exists \

# 젠킨스를 구동하는 pod이 실행될 때 가질 유저 ID, 그룹 ID를 설정
--set master.runAsUser=1000 \
--set master.runAsGroup=1000 \

# 이후 젠킨스 버전에 따른 UI 변경을 막기 위해 젠킨스 버전을 2.249로 픽스
--set master.tag=2.249.3-lts-centos7 \

# 차트로 생성되는 서비스 타입을 로드밸런서로 설정해 외부 IP를 받아옴
--set master.serviceType=LoadBalancer \

# 젠킨스가 http상에서 구동되도록 80포트 지정
--set master.servicePort=80 \

# 젠킨스에 추가로 필요할 설정들을 2~3번째 줄에 변수로 선언함. 이 변수를 호출해 젠킨스에 적용
--set master.jenkinsOpts="$jkopt1 $jkopt2" \

# 젠킨스를 구동하기 위한 환경 설정에 필요한 것들을 위에 변수로 선언해뒀음(4~5번째 줄)
# 이 변수들을 호출해 젠킨스 실행환경(jvm)에 적용함
--set master.javaOpts="$jvopt1 $jvopt2"
```