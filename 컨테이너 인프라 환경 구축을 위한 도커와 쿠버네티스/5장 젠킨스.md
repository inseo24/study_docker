### 4장까지 진행 과정 정리

1. 깃헙 등 저장소에 올린 어플리케이션 소스 코드를 내려받아 도커 컨테이너 이미지로 빌드(docker build)
2. 빌드한 컨테이너 이미지를 쿠버네티스에서 사용할 수 있도록 레지스트리에 등록(docker push)
3. 레지스트리에 등록된 이미지를 기반으로 쿠버네티스 오브젝트를 생성(kubectl create)
4. 생성한 오브젝트(pod/deployement)를 외부에서 접속할 수 있도록 서비스 형태로 노출(kubectl expose)

이런 과정을 파이프 라인이라고 한다.

이를 도구를 통해 자동화할 수 있다.

자동화는 크게 지속적 통합(CI, Continuous Integration), 지속적 배포(CD, Continuous Deployment) 두 가지로 정의되고, 일반적으로 둘을 합쳐 CI/CD라고 한다.

### 컨테이너 인프라 환경에서 CI/CD

CI은 일반적으로 코드를 커밋하고 빌드했을 때 정상적으로 작동하는지 반복적으로 컴증해 애플리케이션의 신뢰성을 높이는 작업이다. CI 과정을 마친 애플리케이션은 신뢰할 수 있는 상태가 된다. 

CD는 CI 과정에서 생성된 신뢰성 있는 애플리케이션을 실제 사용 환경에 자동으로 배포하는 것을 의미한다. 배포할 때 고려할 사항이 여러 가지 있는데, 이를 CD에 미리 정의하면 실수를 줄이고, 실제 적용 시간도 최소화할 수 있다.

개발자가 소스를 커밋하고 푸시하면 CI 단계로 들어간다. CI 단계에서는 애플리케이션이 자동 빌드되고 테스트를 거쳐 배포할 수 있는 애플리케이션인지 확인한다. 테스트를 통과하면 신뢰할 수 있는 애플리케이션으로 간주하고 CD 단계로 넘어간다. CD 단계에서는 애플리케이션을 컨테이너 이미지로 만들어서 파드, 디플로이먼트, 스테이트풀셋 등 다양한 오브젝트 조건에 맞춰 미리 설정한 파일을 통해 배포한다.

**CI/CD 도구**

| 구분 | 팀시티 | 깃허브 액션 | 뱀부 | 젠킨스 |
| --- | --- | --- | --- | --- |
| 설치 방식 | 직접 설치 | 깃허브 연동 | 직접 설치 | 직접 설치 |
| 연계 기능 | 보통 | 보통 | 부족 | 매우 많음 |
| 가격 | 무료/유료 | 무료/유료 | 유료 | 무료 |
| 기능 추가 | 보통 | 매우 다양 | 보통 | 매우 다양 |
| 범용성 | 보통 | 매우 큼 | 보통 | 매우 큼 |
| 정보량 | 부족 | 많음 | 많음 | 매우 많음 |

이외에 클라우드 서비스에서 제공하는 AWS CodeBuilde, CodePipeline, CodeDeploy, GCP CloudBuild, Azure Pipeline 등이 있다. 배포가 중요한 환경이라면 CD 기능이 중점인 Spinnaker나 아르고 CD(Argo CD)를 선택적으로 도입할 수도 있다.

개발자가 작성한 애플리케이션 코드를 소스 코드 저장소에 푸시하면 쿠버네티스 내부에 설치된 젠킨스는 앱 코드를 빌드하고 레지스트리에 푸시한 후 쿠버네티스에서 사용 가능한 형태로 배포한다. 젠킨스는 작업 내용을 아이템 단위로 정의하고 조건에 따라 자동으로 작업을 수행해 효율을 높이고 실수를 줄인다.

컨테이너 인프라 환경에서 젠킨스를 사용하는 주된 이유는 애플리케이션을 컨테이너로 만들고 배포하는 과정을 자동화하기 위함이다. 젠킨스는 컨트롤러와 에이전트 형태를 구성한 다음 배포해야 하며 여기에 필요한 설정을 모두 넣어야 한다. 동적인 변경 사항을 간편하고 빠르게 적용할 수 있도록 도와주는 도구가 2가지가 있다. 하나는 커스터마이즈고 다른 하나는 헬름이다. 

### 배포 간편화 도구 비교하기

| 구분 | kubectl | kustomize | Helm |
| --- | --- | --- | --- |
| 설치 방법 | 쿠버네티스 기본 포함 | 별도 실행 파일 또는 쿠버네티스에 통합 | 별도 설치 |
| 배포 대상 | 정적 yaml 파일 | 커스터마이즈 파일 | 패키지(차트) |
| 주 용도 | 오브젝트 관리 및 배포 | 오브젝트의 가변적 배포 | 패키지 단위 오브젝트 배포 및 관리 |
| 가변적 환경 | 대응 힘듦(yaml 수정 필요) | 간단한 대응 가능 | 복잡한 대응 가능 |
| 기능 복잡도 | 단순 | 보통 | 복잡함 |

### 커스터마이즈의 작동 원리

커스터마이즈는 yaml 파일에 값을 정의해서 사용자가 원하는대로 커스터마이징할 수 있다. kustomize 명령과 create 옵션으로 kustomization.yaml이란 기본 매니페스트를 만들고, 이 파일에 변경해야 하는 값들을 적용한다. 그리고 build 옵션으로 변경할 내용이 적용된 최종 yaml 파일을 저장하거나 변경된 내용이 바로 실행되도록 지정한다.

커스터마이즈로 MetalLB를 구성해보자.

- kustomization.yaml 파일에 원하는 내용을 담고
- 그걸 반영한 MetalLB 매니페스트를 생성하고
- 이 매니페스트를 통해 배포

```bash
# 커스터마이즈 압축 파일을 내려 받은 후 이를 해제하고 /usr/local/bin으로 이동
~/~~~/kustomize-install.sh

# 커스터마이즈에서 리소스 및 주소 할당 영역(pool)을 구성할 때 사용하는 파일 확인을 위해
# 디렉터리를 이동하고 metallb-l2config.yaml, metallb.yaml, namespace.yaml 파일 확인
cd ~/~~/5.2.2
ls

# kustomization.yaml 생성
# --namespace : 작업의 네임스페이스 설정
# --resource : 커스터마이즈 명령을 이용해 kustomization.yaml를 만들기 위한 소스 파일 정의
kustomize create --namespace=metallb-system --resources namespace.yaml, metallb.yaml, metallb-l2config.yaml

# 생성된 yaml 파일 확인
cat kustomization.yaml

# 설치된 이미지를 안정적인 버전으로 유지하기 위해 이미지 태그를 v0.8.2로 지정
kustomize edit set image metallb/controller:v0.8.2
kustomize edit set image metallb/speaker:v0.8.2

# tag 설정 확인
cat kustomization.yaml

# Metallb 설치를 위한 매니페스트 생성
kustomize build

# 배포
kustomize build | kubectl apply -f -

# 정상 배포됐는지 확인
kubectl get pods -n metallb-system

# tag 확인
kubectl describe pods -n metallb-system | grep Image:

# 커스터마이즈로 metallb가 생성됐으니 디플로이먼트 1개 배포 후 load balancer 타입으로 노출하고
# ip 정상 할당되는지 확인
kubectl create deployment echo-ip --image=sysnet4admin/echo-ip
kubectl expose deployment echo-ip --type=LoadBalancer --port=80
kubectl get service echo-ip

# 호스트 노트북에서 192.168.1.11로 접속해 정상 응답 확인
```

### 헬름의 작동 원리

헬름:  쿠버네티스에서 패키지를 쉽게 배포할 수 있도록 패키지를 관리하는 쿠버네티스 전용 패키지 매니저

- 일반적으로 패키지는 실행 파일 + 실행 환경에 필요한 의존성 파일 + 환경 정보 묶음
- 외부 저장소에서 패키지 정보를 받아와 패키지를 안정적으로 관리하는 도구
- 자바의 maven, 리눅스의 yum, apt, 파이썬의 pip라고 생각하면 됨!

패키지 매니저의 역할은 기본적으로 쉬운 설치와 관리다. 그 외에는..

- 패키지 검색
- 패키지 관리: 저장소에서 패키지 정보 확인, 패키지 설치, 삭제, 업그레이드, 되돌리기 등
- 패키지 의존성 관리: 설치할 때 의존하는 소프트웨어 같이 설치, 같이 삭제
- 패키지 보안 관리: 체크섬이라는 값으로 해당 패키지의 소트프웨어나 의존성이 변조됐는지 검사 가능

추가로 헬름을 사용하면 주소 할당 영역도 변경이 가능하다.

헬름 기본 저장소는 아티팩트허브(artifacthub.io)로, 다른 패키지 매니저처럼 외부에 있다. 다른 저장소와 달리 패키지에 대한 경로만 제공한다. 

아티팩트허브 검색을 통해 사용자가 찾고자 하는 애플리케이션 패키지를 검색해 저장된 주소를 확인한다. 이 주소는 각 애플리케이션을 개발하는 주체가 관리한다. 사용자는 설치하려는 애플리케이션의 차트 저장소 주소를 아티팩트허브에서 얻으면 헬름을 통해 주소를 등록한다. 그리고 이를 최신으로 업데이트한 후 차트를 내려받고 설치한다. 이렇게 헬름을 통해 쿠버네티스에 설치된 애플리케이션 패키지를 릴리스라고 한다.

헬름을 통해 배포된 릴리스를 다시 차트를 사용해 업그레이드 할 수 있고 원래대로 되돌릴 수 있다. 또한, 사용하지 않는 헬름 릴리스를 제거할 수도 있다. 

### 헬름으로 MetalLB 한 번에 만들기

```bash
# 헬름 설치, 호환성 이슈로 버전을 고정하고 다운함
export DESIRED_VERSION=v3.2.1; ~/~~~/helm-install.sh

# 아티팩트허브에서 metallb를 검색해 주소를 확인

# 실제 저장소를 등록해 metallb 설치 준비
helm repo add edu https://iac-source.github.io/helm-charts

# 정상 등록되었는지 확인
helm repo list

# 헬름으로 차트 저장소를 추가한 시점의 차트를 로컬 캐시를 저장해 install과 같은 작업 수행시 먼저 
# 로컬에 있는 캐시 정보 참조

# 저장소 추가 이후 변경된 차트가 있으면 변경된 정보를 캐시에 업데이트 할 수 있게 최신 차트 정보 업데이트
helm repo update

# 등록, 업데이트한 저장소로부터 metallb 설치
helm install metallb edu/metallb \
--namespace=metallb-system \
--create-namespace \
--set controller.tag=v0.8.3 \
--set speaker.tag=v0.8.3 \
--set configmap.ipRange=192.168.1.11-192.168.1.29

# 설치된 metallb가 정상 상태인지 확인
kubectl get pods -n metallb-system
kubectl get configmap -n metallb-system

# helm set 옵션 잘 적용되었는지 확인
kubectl describe pods -n metallb-system | grep Image:

# 헬름으로 metallb가 생성됐으니 디플로이먼트 1개 배포 후 load balancer 타입으로 노출하고
# ip 정상 할당되는지 확인
kubectl create deployment echo-ip --image=sysnet4admin/echo-ip
kubectl expose deployment echo-ip --type=LoadBalancer --port=80
kubectl get service echo-ip

# 호스트 노트북에서 192.168.1.11로 접속해 정상 응답 확인
```


### 헬름으로 젠킨스 설치하기

```bash
# 젠킨스로 지속적 통합을 하는 과정에 컨테이너 이미지를 레지스트리에 푸시하는 단계가 있음
# 실습을 위해 레지스트리를 우선 구성
docker ps -f name=registry

# 헬름으로 설치되는 젠킨스는 pod에서 동작하는 애플리케이션이므로 PV를 마운트하지 않으면
# pod이 재시작할 때 내부 볼륨에 저장하는 모든 데이터가 삭제됨
# 이를 방지하기 위해 NFS 디렉터리를 만들고 미리 정의된 nfs-exporte.sh jenkins를 실행
# 해당 스크립트에는 NFS용 디렉터리를 만들고 이를 NFS 서비스로 생성하는 과정이 담김
~/~~/nfs-exporter.sh jenkins

# 만들어진 디렉터리에 부여된 사용자 id, 그룹 id 확인
ls -n /nfs-shared

#젠킨스를 헬름 차트로 설치해 앱을 사용하면 젠킨스의 여러 설정 파일과 구성 파일들이 PVC를 통해 PV에 파일로 저장됨
# 이 때 PV에 적절한 접근 ID를 부여하지 않으면 PVC를 사용해 파일을 읽고 쓰는 기능에 문제가 생길 수 있음
# 문제 방지를 위해 젠킨스 PV가 사용할 NFS 디렉터리에 대한 접근 ID를 1000번으로 설정
chown 1000:1000 /nfs_shared/jenkins/
ls -n /nfs_shared

# 사전 구성된 jenkins-volume.yaml 파일을 이용해 PV, PVC 구성하고 확인
kubectl apply -f ~/~~/jenkins-volume.yaml
kubectl get pv jenkins
kubectl get pvc jenkins

# 젠킨스 설치를 위해 필요한 인자를 포함해 사전 구성된 jenkins-install.sh를 실행해 설치
~/~~/jenkins-install.sh

# 젠킨스 디플로이먼트 정보를 비교해서 보기 위해 디플로이먼트 배포 확인
# 젠킨스가 마스터 노드에 있는 걸 확인
kubectl get deployment
kubectl get service jenkins
kubectl get pod -o wide

# 마스터에도 pod이 배포 될 수 있을까?
# 상태 비교 (nl : number lines of files, 줄 번호 추가)
kubectl get node m-k8s -o yaml | nl
...
taints:
	- effect: NoSchedule
	  key: node-role.kubernetes.io/master

...
tolerations:
- effect: NoSchedule
	key: node-role.kubernetes.io/master

# 출력되는 사항 중 taints, tolerations이 이런 결과를 만듦
```

일반적으로 테인트와 톨러레이션은 혼합해서 사용함

테인트: 손에 잡기 싫은 것, 가지지 말았으면 하는 것

톨러레이션: 테인트를 피하기 위해 참아내야 하는 것

사전적인 의미로는 이 정도로 이해하면 된다.

쿠버네티스에선 사전적인 의미와는 반대다. 매우 특별하게 취급해야 하는 것을 테인트로 설정하고, 쉽게 접근하지 못하게 만든다. 그리고 톨러레이션이란 특별한 키를 가져야만 여기에 출입할 수 있게 한다.

즉, 현재 상태에서 마스터 노드에 테인트가 설정돼 있어 특별한 목적으로 사용되는 노드라고 명시해 두었다. 일반적으로 마스터 노드 이외에도 GPU 노드, DB 전용 노드 등의 특별한 목적으로 사용될 때 주로 사용한다.

현재 이 예시에선 관리 편의를 위해 젠킨스 컨트롤러가 여러 곳에 스케줄되지 않고 마스터 노드에서만 스케줄될 수 있게 구성했다. 

테인트와 톨러레이션의 관계를 정의하는 것으로 배포를 유연하게 만들 수 있다.

테인트는 key, value, 그리고 key의 값에 따른 효과의 조합을 통해 테인트를 설정한 노드의 pod 배치 기준을 제시한다. 톨러레이션은 key, value, 효과(effect), 연산자(operator)를 갖고 있다.

테인트의 키와 값의 조합은 테인트를 설정한 노드가 어떤 노드인지 구분하기 위해 사용한다. 키는 필수로 설정해야 하지만 값은 생략할 수 있다. 위에 나온 key: [node-role.kubernetes.io/master](http://node-role.kubernetes.io/master) 는 이 노드가 마스터의 역할을 함을 나타내기 위함이다.

효과(effect)는 테인트와 톨러레이션의 요소인 키 또는 값이 일치하지 않는 pod가 노드에 스케줄되려고 하는 경우 어떤 동작을 할 것인지 나타낸다. 효과는 NoSchedule, PreferNoSchedule, NoExecute을 값으로 가질 수 있는데 효과에 따라 테인트를 설정한 노드는 pod을 새로 배치하는 경우와 pod가 이미 배치된 노드에 대한 동작이 다르다. 

| 효과 | 테인트가 설정된 노드에 대한 신규 배치 | pod이 배치된 노드에 테인트 설정 |
| --- | --- | --- |
| NoSchedule | 노드에 pod 배치 거부 | 노드에 존재하는 pod 유지 |
| PreferNoSchedule | 다른 노드에 pod 배치가 불가능할 때는 노드에 pod 배치 | 노드에 존재하는 pod 유지 |
| NoExecute | 노드에 pod 배치를 거부 | pod을 노드에서 제거 |

톨러레이션에서 키와 효과는 반드시 일치해야 한다. 연산자는 기본적으로 Equal로 동작해 테인트와 톨러레이션을 비교하는 역할을 한다. Exist 연산자는 비교할 키와 값이 존재한다는 가정으로 테인트에 진입할 수 있는 만능 키로 바꿔주는 역할을 한다.

헬름을 통해 젠킨스를 설치했던 스크립트인 [jenkins-install.sh](http://jenkins-install.sh) 내용을 살펴보자.

```bash
#!/usr/bin/env bash

# 기본 설정으로 30분 넘게 사용하지 않으면 세션이 종료되므로 실습에 방해되니
# 세션 유효시간을 1440분(하루)로 변경, 세션 정리 시간 또한 86400초(하루)로 설정
jkopt1="--sessionTimeout=1440"
jkopt2="--sessionEviction=86400"

# 기본 설정으론 시간대가 맞지 않으니 따로 설정
jvopt1="-Duser.timezone=Asia/Seoul"

# 쿠버네티스를 위한 젠킨스 에이전트 노드 설정은 Pod Template을 통해 설정값이 입력됨
# 문제는 가상 머신인 마스터 노드가 재시작하게 되면 이 설정이 초기화되니 
# 설정값을 미리 입력해둔 yaml을 깃헙 저장소에서 가져오게 설정 
jvopt2="-Dcasc.jenkins.config=https://raw.githubusercontent.com/sysnet4admin/_Book_k8sInfra/main/ch5/5.3.1/jenkins-config.yaml"

# edu 차트 저장소의 jenkins 차트를 이용해 jenkins 릴리스를 설치
helm install jenkins edu/jenkins \

# PVC 동적 프로비저닝을 사용할 수 없는 가상 머신 환경이므로 이미 만들어둔 jenkins라는 이름의
# PVC 사용을 설정
--set persistence.existingClaim=jenkins \

# 젠킨스 접속 시 사용할 관리자 비밀번호를 admin으로 설정
# 이 값을 설정하지 않을 경우엔 설치 과정에서 젠킨스가 임의로 생성한 비밀번호를 사용
--set master.adminPassword=admin \

# 젠킨스의 컨트롤러 pod를 쿠버네티스 마스터 노드 m-k8s에 배치하도록 선택
# nodeSelector: 그 뒤에 따라오는 문자열과 일치하는 레이블을 가진 노드에 pod을 스케줄링
--set master.nodeSelector."kubernetes\.io/hostname"=m-k8s \

# 마스터 노드로 pod 배치를 위한 추가 옵션(이 옵션이 없으면 배치가 안됨)
# 테인트가 설정된 상태이기 때문에 톨러레이션 옵션을 설정(톨러레이션 -> 테인트에 대한 예외)
# 톨러레이션에 관해 key, effect, operataor를 설정
--set master.tolerations[0].key=node-role.kubernetes.io/master \
--set master.tolerations[0].effect=NoSchedule \
--set master.tolerations[0].operator=Exists \

# 젠킨스를 구동하는 pod이 실행될 때 가질 유저 ID, 그룹 ID를 설정
--set master.runAsUser=1000 \
--set master.runAsGroup=1000 \

# 이후 젠킨스 버전에 따른 UI 변경을 막기 위해 젠킨스 버전을 2.249로 픽스
--set master.tag=2.249.3-lts-centos7 \

# 차트로 생성되는 서비스 타입을 로드밸런서로 설정해 외부 IP를 받아옴
--set master.serviceType=LoadBalancer \

# 젠킨스가 http상에서 구동되도록 80포트 지정
--set master.servicePort=80 \

# 젠킨스에 추가로 필요할 설정들을 2~3번째 줄에 변수로 선언함. 이 변수를 호출해 젠킨스에 적용
--set master.jenkinsOpts="$jkopt1 $jkopt2" \

# 젠킨스를 구동하기 위한 환경 설정에 필요한 것들을 위에 변수로 선언해뒀음(4~5번째 줄)
# 이 변수들을 호출해 젠킨스 실행환경(jvm)에 적용함
--set master.javaOpts="$jvopt1 $jvopt2"
```


## 젠킨스 살펴보기

젠킨스 컨트롤러는 마스터 노드에 설치했지만 젠킨스 에이전트는 필요 시 생성디고 작업을 마치면 삭제되는 임시적인 구조를 가짐. 젠킨스 에이전트가 작업 내용들을 삭제 전에 젠킨스 컨트롤러에 저장돼야 하며, 이를 위해 젠킨스 에이전트 서비스가 항상 동작하고 있다.

젠킨스 컨트롤러가 단독 설치될 경우 컨트롤러가 설치된 서버에서 젠킨스 자체 시스템 관리, CI/CD 설정, 빌드 등의 작업을 모두 젠킨스 컨트롤러 단일 노드에서 수행한다. 하지만 컨트롤러-에이전트 구조로 설치할 경우 컨트롤러는 젠킨스 자체의 관리 및 CI/CD와 관련된 설정만을 담당하고 실제 빌드 작업은 에이전트로 설정된 노드에서 이뤄진다.

따라서 컨트롤러 단독 설치는 일반적으로 간단한 테스트에서만 사용되고 주로 컨트롤러-에이전트 구조로 사용한다.

### 젠킨스 접속하기

로그인 후 메인화면 좌측 메뉴

1. 새로운 Item: 젠킨스를 통해 빌드한 작업을 아이템이라고 한다.
2. 사람: 사용자를 관리하는 메뉴. 별도 데이터베이스를 갖고 자체적으로 사용자를 관리하는 방법이 있는데 현재는 데이터베이스가 없는 환경이라 직접 사용자를 관리하도록 구성돼 있다.
3. 빌드 기록: 젠킨스 작업에 대한 성공, 실패, 진행 내역을 여기서 볼 수 있다.
4. Jenkins 관리: 젠킨스의 시스템, 보안, 도구, 플러그인 등 각종 설정을 수행하는 곳
    1. 시스템 설정: 메인 화면에 표시될 문구, 동시에 실행할 수 있는 실행기 개수, 젠킨스르 접속할 수 있는 경로, 관리자 정보, 시스템 전체에 적용할 수 있는 환경변수, 시스템에서 공통적으로 활용해야 하는 플러그인 파일 경로와 설정 정보 등을 이곳에서 설정할 수 있다.
    2. Global Tool Configuration: 빌드 과정에서 사용하는 도구(maven, gradle, jdk, git, docker 등)의 경로 및 옵션 설정. 
    3. 플러그인 관리: 사용할 플러그인 설치, 삭제, 업데이트
    4. 노드 관리: 사용하는 노드 추가, 삭제, 세부 설정, 상태 모니터링. 젠킨스에서도 작업을 수행할 수 있는 각 단위를 노드라고 하고, 노드에 레이블을 붙여 관리하거나 동작 방식을 설정할 수 있다.
    5. Configuration as Code: 젠킨스 설정을 내보내거나 불러올 수 있다. 다른 곳에서 구성한 젠킨스 설정을 옮겨오거나 내 젠킨스 설정을 내보내 공유할 수 있다. 새로운 젠킨스를 구성해 현재 젠킨스 설정을 이전할 때 유용한 메뉴.
    6. Manage Credentials: 젠킨스에서 사용하는 플러그인에 필요한 접근 키, 비밀 키, API 토큰과 같은 접속에 필요한 인증 정보를 관리. 
5. My Views: 젠킨스에서 각종 작업을 분류해 모아서 볼 수 있는 대시보드
6. Lockable Resources: 젠킨스에선 한 번에 여러 작업이 동시에 일어날 수 있다. 이 때 작업이 진행중이라면 옵션에 따라 다른 작업은 대기를 해야 할 수 있다. 이를 동시성 문제라고 하며 젠킨스에서 작업이 끝날 때까지 같은 작업을 하지 못하게 하는 잠금 장치를 Lockable Resoruce로 설정할 수 있다.
7. New View: 대시보드인 View를 생성하는 작업

### 젠킨스 컨트롤러 설정하기

홈화면 젠킨스 관리 > 시스템 설정 에서 젠킨스 컨트롤러를 설정하게 된다.

1. 시스템 메시지: 젠킨스 메인 웹 페이지에서 접속했을 때 나타나는 메시지를 입력한다. 이 메시지를 통해 사용자에게 젠킨스에 대한 소개나 간단한 안내를 할 수 있다.
2. ‘# of executors’: 동시에 빌드를 수행할 수 있는 실행기의 개수를 설정하는 옵션. 이 옵션은 컨트롤러 노드에서 몇 개까지 빌드를 실행할 수 있을 지 설정할 수 있다. 현재 설치된 젠킨스의 경우 에이전트 pod를 통해 빌드 작업을 생성하므로 이 옵션을 0으로 설정하는 것이 바람직하다.
3. Labels: 노드를 구분할 레이블을 지정. 이렇게 설정한 레이블을 통해 Usage 옵션을 사용하면 특정 작업을 어떤 노드에서 작업할지 결정할 수 있다.
4. Usage: 젠킨스의 빌드 작업에 대해 젠킨스 노드가 어떻게 처리할지 설정한다. Use this node as much as possible(이 노드를 가능한 많이 사용) 옵션은 빌드 작업을 수행할 때 별도의 조건 없이 노드에 빌드를 할 수 있는 환경이라면 현재 노드에서 빌드를 진행하도록 설정하는 것이다. 이런 옵션은 일반적인 환경에서 빌드 작업에 적합하다. Only build jobs with label expression matching this node(이 노드와 일치하는 레이블 표현식을 가진 작업만 빌드) 옵션은 빌드와 대상의 레이블이 같아야 빌드할 수 있다. 주로 빌드 환경이 다른 플랫폼에서 빌드를 수행할 때 사용된다.
5. Quiet period: 빌드 작업이 시작될 때까지 잠시 대기하는 시간을 설정하는 값. 단위는 초 단위고, 짧은 시간에 변경된 코드에 대해 중복으로 작업을 수행하지 않고 가장 마지막으로 변경된 코드를 빌드하기 위해 설정한다.
6. SCM checkout retry count: 소스 코드 저장소로부터 파일을 가져오지 못한 경우 몇 번 재시도를 할 지 설정하는 옵션이다. SCM이란 소스 코드 관리의 약자로 소스 코드 통합, 관리, 이력 추적을 위해 사용되는 시스템을 의미한다.
7. Restrict project naming: 젠킨스를 통해 만들어지는 작업의 이름 규칙을 설정하는 옵션이다. 체크박스에 체크하면 이름 규칙을 편집할 수 있는 영역이 생기며 제약 조건은 정규식 패턴으로 작성해 적용할 수 있다. 현재 설치된 젠킨스 전략은 Default로 자유롭게 설정 가능.
8. Jenkins URL: 설치된 젠킨스 컨트롤러의 접속 주소다. 앞서 헬름을 설치할 때 로드밸런서를 통해 설정될 IP인 192.168.1.11을 설정했다. 이 주소는 젠킨스가 외부로 알림을 보내거나 자신의 주소를 알려준다.
9. Resource Root URL: 빌드 결과물과 같은 내용을 외부에 공개하기 위해 사용되는 주소로 Jenkins URL과는 다르다. 이 실습에선 빌드 결과물을 외부로 공개할 수 없는 가상 환경에 구성함으로 설정하지 않음.